# src/codechallenge2025/participant_solution.py
"""
Easy Participant Template for #codechallenge2025

You ONLY need to implement the function: match_single

The find_matches function is provided for you — no need to change it!
"""

import pandas as pd
from typing import List, Dict, Any


def match_single(
    query_profile: Dict[str, Any], database_df: pd.DataFrame
) -> List[Dict]:
    """
    Find the top 10 candidate matches for a SINGLE query profile.

    Args:
        query_profile: dict with 'PersonID' and locus columns (e.g. {'PersonID': 'Q001', 'TH01': '9,9.3', ...})
        database_df: Full database as pandas DataFrame (500k rows)

    Returns:
        List of up to 10 candidate dicts, sorted by strength (best first):
        [
            {
                "person_id": "P000123",
                "clr": 1e15,                    # Combined Likelihood Ratio
                "posterior": 0.99999,           # Optional: posterior probability
                "consistent_loci": 20,
                "mutated_loci": 1,
                "inconclusive_loci": 0
            },
            ...
        ]
    """
    # TODO: Replace this dummy with your real matching logic!
    # Example: return empty list (safe default)
    return []

    # Helpful tip: you can compute a simple score like number of shared alleles
    # Example skeleton:
    """
    candidates = []
    query_id = query_profile['PersonID']
    
    for _, candidate in database_df.iterrows():
        if candidate['PersonID'] == query_id:
            continue  # skip self
        
        score = your_scoring_function(query_profile, candidate)
        if score > threshold:
            candidates.append({
                "person_id": candidate['PersonID'],
                "clr": score,
                "posterior": 0.99,  # optional
                "consistent_loci": 18,
                "mutated_loci": 0,
                "inconclusive_loci": 3
            })
    
    # Sort by CLR descending and take top 10
    candidates.sort(key=lambda x: x['clr'], reverse=True)
    return candidates[:10]
    """


# ============================================================
# DO NOT MODIFY BELOW THIS LINE — This runs your function!
# ============================================================


def find_matches(database_path: str, queries_path: str) -> List[Dict]:
    """
    Main entry point — automatically tested by CI.
    Loads data and calls your match_single for each query.
    """
    print("Loading database and queries...")
    database_df = pd.read_csv(database_path)
    queries_df = pd.read_csv(queries_path)

    results = []

    print(f"Processing {len(queries_df)} queries...")
    for _, query_row in queries_df.iterrows():
        query_id = query_row["PersonID"]
        query_profile = query_row.to_dict()

        print(f"  Matching query {query_id}...")
        top_candidates = match_single(query_profile, database_df)

        results.append(
            {
                "query_id": query_id,
                "top_candidates": top_candidates[:10],  # Ensure max 10
            }
        )

    print("All queries processed.")
    return results
